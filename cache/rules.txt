HTTP Caching rules

1. 	Если только Last-Modified заголовок в ответе и этот заголовок меньше чем текущая дата, то можно кешировать на срок 10% от возраста ответа.

2. 	Если только заголов Cache-Control: max-age=604800, то сохраняем в кеш от текущей даты

3. 	Всегда в ответе из кеша добавляем заголовок Age с перезаписываеним уже имеющегося такого заголовка - сколько секунд ответ лежит в кеше (с момента записи в кеш).
    Клиенты в этом случае должны определять свежесть ответа по формуле max-age минус Age.
   
4. 	Загловки ответа оставляем все без изменения, кроме Connection (удаляем из кеша), и добавляем Age, Content-Length и X-Cache.

5. 	Если оба заголовка присуствуют в ответе "Expires" и "Cache-Control: max-age", то приоритет должен быть у инструкции "Cache-Control: max-age".

6. 	Если ответ сервера по одному и тому же URL отличается в зависимости от переданных клиентом заголовков (например: Accept, Accept-Language, Accept-Encoding, User-Agent),
    то кеширующий сервер должен выставить заголовок Vary и перечислить в нём через запятую все такие заголовки.

7. 	Если ответ сервера на один и тот же URL отличается персонально для каждого юзера (по загловкам Cookie или Autorization),
    то для таких ответов серверу нужно выставить загловок "Cache-Control: private".

8.	Если вышестоящий сервер выставил заголовки, позволяющие закешировать его ответ, но не указал public или private для заголовка Cache-Control, то нужно руководсвоваться следующими правилами:
    - если есть персонализированные заголовки (Cookie, Set-Cookie или Authorization), то считаем кеш как private
    - если персонализированный ответ всё равно нужно закешировать на стороне proxy, то вышестоящий сервер обязан выставить директиву public и(или) s-maxage, при этом в кеш не сохраняем персонализированные заголовки.
    - если персонализированных заголовков нет, то кеш можно счиатать public и смело кешировать на стороне proxy.
    - если персональный ответ можно кешировать, но нужно сохранить требование авторизации для каждого пользователя у вышестоящего сервера, то необходимо выставить заголовок "Cache-Control: public, no-cache"

9.	Валидация (ревалидация) кеша - отправка conditional запроса на сервер с заголовком If-Modified-Since или If-None-Match.

10.	Если мы получаем заголовок "Cache-Control: max-age=3600", то мы кешируем ответ на 3600 от текущей даты, а не от "Last-Modified", если он присутствует также.
    В этом случае кеш можно отдавать 3600 сек от от текущей даты и потом отправляем conditional зарос If-Modified-Since на вышестоящий сервер.
    После получения 304 Not Modified кеширующий сервер меняет состояние кеша из устаревший в свежий на указанное число секунд.

11.	Если в ответе одновременно загловки ETag и "Cache-Control: max-age=3600", то 3600 секунд мы не запрашиваем conditional запросов.

12.	Согласно RFC9110 серверу лучше отдавать оба загловка ETag и Last-Modified,
    а клиентам рекомендуется посылать в conditional запросе оба загловка If-Modified-Since и If-None-Match.
    В этом случае предпочтение должно отдаваться загловку ETag (If-None-Match).

13.	Для принудительная ревалидация серверу необходимо отправлять заголовок "Cache-Control: no-cache" совместо с загловками "Last-Modified" and "ETag".
    Этот заголовок имеет точно такой же смысл - "Cache-Control: max-age=0, must-revalidate".
    Используется к примеру для index.html

14.	Нельзя кешировать нигде и никогда - отправляем заголовок "Cache-Control: no-store, private"

15.	Для никогда неизменяемого контента должен быть использован cache busting - добавление загловка "Cache-Control: public, max-age=31536000, immutable",
    где 31536000 - это максимально возможное значение директивы max-age.

16.	Рекомендуется всегда и во все ответы сервера добавлять заголовок Cache-Control, чтобы нишестоящие сервера не пытались закешировать ответ по своим эвристикам.

17.	На всякий случай добавляйте в ответы c заголовком "Set-Cookie" (персональный ответ) предохранитель от промежуточного кеширования - заголовок "Cache-Control: no-cache, private"

18.	Если нет ни одного из перечисленных ниже заголовков ответа, то ответ считается некешируемым (no-store):
    - Expires
    - Last-Modified
    - Cache-Control
    - ETag

19.	Не используйте POST запросы для идемпотентных запросов. Большинство прокси серверов не закеширует ответ даже при наличии нужных заголовков ответа.

20.	Помните, что если вы отправляете какую-либо информацию в URL параметрах запроса, то эти параметры могут сохраниться в кеше.
    Также старайтесь не передавать специфичную для конкретного пользователя информацию в URL, кроме случаев, когда это необходимо.

21.	Старайтесь всегда генерировать, когда это возможно, заголовок ответа Content-Length.
    Это позволит клиентам запрашивать несколько ресурсов внутри одного TCP соединения вместо создания нового соединения для каждого запроса.
    Это простое правило серьезно ускоряет работу с веб сервером.

22.	Старайтесь измбегать авторизация пользоватлей (персонализированные заголовки) для статического контента, чтобы такие ответы могли легче проходить кеширование.

23. Неполные успешные запросы 206 (Partial Content) могут быть закешированы, только если они поддерживают заголовки Range и Content-Range.
    Кеш таких ответов можно отдавать клиентам только после того, когда запрос полностью загрузится и его можно будет отдать под кодом 200.

24. Если от клиента на промежуточный кеш приходит conditional запрос, который не валидируется, то кеш возвращает 200 ОК с содержимом кеша вместо 304 Not Modified с корректными валидаторами.

25. Промежуточный кеш может обновлять валидируемые данные асинхронно в фоне.
    Но так лучше делать только для данных, которые точно будут вскоре запрошены, чтобы не тратить ресурсы впустую.

26. Если conditional запрос на вышестоящий сервер завершился 50х ошибкой, то можно использовать старый кеш, если ни одна из перечисленных ниже директив не была ранее выставлена для кешированного ответа:
    - no-cache
    - must-revalidate
    - s-maxage
    - proxy-revalidate

27. Все загловки ответа на conditional запрос должны переписать имеющиеся такие же заголовки у сохраненного ответа.

28. Если на в кеше ответ, полученный через GET метод, по точно такому же URI отправляется изменяющий запрос (POST, PUT, DELETE, PATCH), то кеш должен автоматически пометить сохраненный кеш для таких URI как устаревший.

29. Если промежуточный кеш получает 50х ошибку у вышестоящего сервера, то кеш отправляет клиенту ошибку 504 Gateway Timeout.



# CODE EXAMPLES

w.Header().Set("Last-Modified", modtime.UTC().Format(TimeFormat))

func writeNotModified(w ResponseWriter) {
	// RFC 7232 section 4.1:
	// a sender SHOULD NOT generate representation metadata other than the
	// above listed fields unless said metadata exists for the purpose of
	// guiding cache updates (e.g., Last-Modified might be useful if the
	// response does not have an ETag field).
	h := w.Header()
	delete(h, "Content-Type")
	delete(h, "Content-Length")
	delete(h, "Content-Encoding")
	if h.Get("Etag") != "" {
		delete(h, "Last-Modified")
	}
	w.WriteHeader(StatusNotModified)
}

etag := header.Get("ETag")                             //  If-None-Match
lastModified := parseTime(header.Get("Last-Modified")) //  If-Modified-Since
// rw.ResponseWriter.Header().Get("Expires")
// rw.ResponseWriter.Header().Get("Age")
// rw.ResponseWriter.Header().Get("Date")
vary := header.Get("Vary")


HTTP/1.1 200 OK
Accept-Ranges: none
Age: 2919
Cache-Control: public, max-age=3600
Content-Encoding: br
Content-Length: 724
Content-Type: text/javascript
Date: Tue, 16 Jul 2024 07:09:54 GMT
ETag: W/"496e1e4ae72df3a4b647cb6bd577cf62"
Expires: Tue, 16 Jul 2024 07:14:09 GMT
Last-Modified: Mon, 15 Jul 2024 00:41:35 GMT
Server: Google Frontend
Strict-Transport-Security: max-age=63072000
Vary: Accept-Encoding
Via: 1.1 google
x-cache: hit
X-Content-Type-Options: nosniff
X-Frame-Options: DENY


GOLANG FILE SERVER RERSPONSE:
HTTP/1.1 200 OK
Content-Length: 195447
Accept-Ranges: bytes
Content-Type: text/html; charset=utf-8
Date: Thu, 18 Jul 2024 12:19:42 GMT
Last-Modified: Thu, 18 Jul 2024 12:15:27 GMT