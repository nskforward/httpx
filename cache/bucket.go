package cache

import (
	"net/http"
	"os"
	"path/filepath"
	"sync"
	"sync/atomic"
	"time"

	"github.com/google/uuid"
)

/*
Каждый URI смотрит на 1 бакет.
Внутри бакета по данному одному URI может быть несколько кешей, отличающихся собственным ключом, задаваемый во время создания кеша функцией keyFunc
Разные группы пользователей видят свой контент по одному и то му же URI.
*/
type Bucket struct {
	sync.RWMutex
	store    *Store
	key      string
	dir      string
	keyStore sync.Map
	deleted  atomic.Bool
	keyFunc  func(*http.Request) string
}

func (b *Bucket) IsDeleted() bool {
	return b.deleted.Load()
}

/*
GetKey returns resource id previosly saved by Set function for current request URI
*/
func (b *Bucket) GetKey(r *http.Request) *Entry {
	b.RLock()
	defer b.RUnlock()

	if b.keyFunc == nil {
		return nil
	}

	key := b.keyFunc(r)
	if key == "" {
		return nil
	}

	res, ok := b.keyStore.Load(key)
	if !ok {
		return nil
	}

	return res.(*Entry)
}

/*
SetKey sets the new key generation func for currunt request URI and returns uniq resource id
*/
func (b *Bucket) SetKey(r *http.Request, ttl time.Duration, keyFunc func(*http.Request) string) *Entry {
	b.Lock()
	defer b.Unlock()

	b.keyFunc = keyFunc

	key := keyFunc(r)

	if key == "" {
		return nil
	}

	entry := &Entry{
		id:     uuid.New().String(),
		key:    key,
		file:   filepath.Join(b.dir, key),
		bucket: b,
		from:   time.Now(),
		to:     time.Now().Add(ttl),
	}

	b.keyStore.Store(key, entry)

	return entry
}

/*
DelKey deletes the key generated by saved key generation func for current request URI (invalidate cache)
*/
func (b *Bucket) Delete() {
	b.deleted.Store(true)
	b.Lock()
	defer b.Unlock()
	os.RemoveAll(b.dir)
	b.store.buckets.Delete(b.key)
}
