package cache

import (
	"net/http"
	"os"
	"path/filepath"
	"sync"
	"sync/atomic"
	"time"

	"github.com/google/uuid"
)

/*
Каждый URI смотрит на 1 бакет.
Внутри бакета по данному одному URI может быть несколько кешей, отличающихся собственным ключом, задаваемый во время создания кеша функцией keyFunc
Разные группы пользователей видят свой контент по одному и то му же URI.
*/
type Bucket struct {
	sync.RWMutex
	store    *Store
	key      string
	dir      string
	keyStore sync.Map
	deleted  atomic.Bool
	keyFunc  func(*http.Request) string
}

func (b *Bucket) IsDeleted() bool {
	return b.deleted.Load()
}

func (b *Bucket) Dir() string {
	return b.dir
}

/*
GetKey returns resource id previosly saved by Set function for current request URI
*/
func (b *Bucket) GetKey(r *http.Request) *Entry {
	b.RLock()
	defer b.RUnlock()

	if b.keyFunc == nil {
		return nil
	}

	key := b.keyFunc(r)
	if key == "" {
		return nil
	}

	res, ok := b.keyStore.Load(key)
	if !ok {
		return nil
	}

	return res.(*Entry)
}

/*
SetKey sets the new key generation func for currunt request URI and returns uniq resource id
*/
func (b *Bucket) SetKey(r *http.Request, ttl time.Duration, keyFunc func(*http.Request) string) *Entry {
	b.Lock()
	defer b.Unlock()

	b.keyFunc = keyFunc

	key := keyFunc(r)

	if key == "" {
		return nil
	}

	res, loaded := b.keyStore.LoadOrStore(key, &Entry{
		status: filling,
	})
	entry := res.(*Entry)
	if !loaded {
		entry.Lock()
		entry.id = uuid.New().String()
		entry.key = key
		entry.file = filepath.Join(b.dir, Hash(key))
		entry.bucket = b
		entry.from = time.Now()
		entry.to = entry.from.Add(ttl)
		entry.status = 0
		entry.Unlock()
	}

	return entry
}

/*
DelKey deletes the key generated by saved key generation func for current request URI (invalidate cache)
*/
func (b *Bucket) Delete() {
	b.Lock()
	defer b.Unlock()
	b.deleted.Store(true)
	b.store.buckets.Delete(b.key)
	os.RemoveAll(b.dir)
}

func (b *Bucket) Tag(tagName string) {
	t := b.store.GetTag(tagName)
	t.Add(b)
}
